{"ast":null,"code":"import Swal from 'sweetalert2';\nimport { CommonModule } from '@angular/common';\nimport { InjectionToken, ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output, ComponentFactoryResolver, Directive, HostListener, ViewContainerRef, TemplateRef, ApplicationRef, Host, Injector, NgModule } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * Represents an object of targets for <swal> partials (use with *swalPartial directive).\n * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction SwalPartialComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nlet SwalPartialTargets = /*#__PURE__*/(() => {\n  class SwalPartialTargets {\n    constructor() {\n      this.title = () => Swal.getTitle();\n\n      this.content = () => Swal.getContent();\n\n      this.actions = () => Swal.getActions();\n\n      this.confirmButton = () => Swal.getConfirmButton();\n\n      this.cancelButton = () => Swal.getCancelButton();\n\n      this.footer = () => Swal.getFooter();\n    }\n\n  }\n\n  SwalPartialTargets.ɵfac = function SwalPartialTargets_Factory(t) {\n    return new (t || SwalPartialTargets)();\n  };\n\n  SwalPartialTargets.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SwalPartialTargets,\n    factory: SwalPartialTargets.ɵfac\n  });\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n   */\n\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n   */\n\n  /** @type {?} */\n\n  return SwalPartialTargets;\n})();\nconst SwalDefaults = new InjectionToken('SwalDefaults');\n/**\n * @param {?=} options\n * @return {?}\n */\n\nfunction swalDefaultsProvider(options = {}) {\n  return {\n    provide: SwalDefaults,\n    useValue: options\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of \\@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe.\n *\n * /!\\ Some SweetAlert options aren't \\@Inputs but \\@Outputs: onBeforeOpen, onOpen, and onClose (without \"on*\" prefix).\n *     However, preConfirm and inputValidtor are still \\@Inputs because there are not event handlers, there can't be\n *     multiple listeners and we need the Promise they must return.\n *\n * /!\\ You can notice that the SweetAlert2 `useRejections` and `expectRejections` are the only one to not have\n *     an \\@Input(). That's because they are deprecated and not using the default value of these parameters leads to\n *     clunky control flow. They are supported (use [options]=\"{}\"), but please don't use them.\n */\n\n\nlet SwalComponent = /*#__PURE__*/(() => {\n  class SwalComponent {\n    /**\n     * @param {?} defaultSwalOptions\n     */\n    constructor(defaultSwalOptions) {\n      this.defaultSwalOptions = defaultSwalOptions;\n      /**\n       * Emits a BeforeOpenEvent when the modal DOM element has been created.\n       * Useful to perform DOM mutations before the modal is shown.\n       */\n\n      this.beforeOpen = new EventEmitter();\n      /**\n       * Emits an OpenEvent when the modal is shown.\n       */\n\n      this.open = new EventEmitter();\n      /**\n       * Emits a CloseEvent when modal get closed.\n       */\n\n      this.close = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n       *\n       * Example:\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n\n      this.confirm = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Cancel\" (or dismisses the modal by any other way).\n       * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the\n       * value of a rejected \"preConfirm\".\n       *\n       * Example:\n       *     public handleCancel(reason: string): void {\n       *         // reason can be 'cancel', 'overlay', 'close', and 'timer'\n       *         // ... do something\n       *     }\n       */\n\n      this.cancel = new EventEmitter();\n      this.nativeSwal = Swal;\n      this.isCurrentlyShown = false;\n      this.touchedProps = new Set();\n      this.markTouched = this.touchedProps.add.bind(this.touchedProps); //=> Force `this` scope of show() on this component\n      //   Useful for doing things like (click)=\"mySwal.show()\".\n\n      this.show = this.show.bind(this);\n    }\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the \\@Inputs for practical/philosophical reasons ;\n     *  - there are missing \\@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Be aware that the options defined in this object will override the \\@Inputs of the same name.\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    set options(options) {\n      Object.assign(this, options);\n      Object.keys(options).forEach(this.markTouched);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get options() {\n      /** @type {?} */\n      const options = {}; //=> We will compute the options object based on the option keys that are known to have changed.\n      // That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially avoiding\n      // side effects.\n\n      this.touchedProps.forEach(prop => {\n        options[prop] =\n        /** @type {?} */\n        this[prop];\n      });\n      return options;\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      Object.keys(changes).filter(prop => prop !== 'options').forEach(this.markTouched);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.isCurrentlyShown) {\n        Swal.close();\n      }\n    }\n    /**\n     * Shows the SweetAlert.\n     *\n     * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n     * Otherwise, (confirm)=\"myHandler($event)\" and (cancel)=\"myHandler($event)\" can be used in templates.\n     * @return {?}\n     */\n\n\n    show() {\n      //=> Build the SweetAlert2 options\n\n      /** @type {?} */\n      const options = Object.assign({}, this.defaultSwalOptions, this.options, {\n        onBeforeOpen: modalElement => {\n          this.beforeOpen.emit({\n            modalElement\n          });\n        },\n        onOpen: modalElement => {\n          this.isCurrentlyShown = true;\n          this.open.emit({\n            modalElement\n          });\n        },\n        onClose: modalElement => {\n          this.isCurrentlyShown = false;\n          this.close.emit({\n            modalElement\n          });\n        }\n      }); //=> Show the Swal!\n\n      /** @type {?} */\n\n      const promise = Swal.fire(options); //=> Handle (confirm) and (cancel) @Outputs\n      // tslint:disable-next-line:no-string-literal\n\n      /** @type {?} */\n\n      const useRejections =\n      /** @type {?} */\n      options.useRejections;\n      promise.then(result => {\n        if (useRejections) {\n          this.confirm.emit(result);\n        } else if ('value' in result) {\n          this.confirm.emit(result.value);\n        } else {\n          this.cancel.emit(result.dismiss);\n        }\n      }, err => {\n        if (useRejections) {\n          this.cancel.emit(err);\n        }\n      }); //=> Return the unaltered promise\n\n      return promise;\n    }\n\n  }\n\n  SwalComponent.ɵfac = function SwalComponent_Factory(t) {\n    return new (t || SwalComponent)(ɵngcc0.ɵɵdirectiveInject(SwalDefaults));\n  };\n\n  SwalComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SwalComponent,\n    selectors: [[\"swal\"]],\n    inputs: {\n      options: \"options\",\n      title: \"title\",\n      titleText: \"titleText\",\n      text: \"text\",\n      html: \"html\",\n      footer: \"footer\",\n      type: \"type\",\n      backdrop: \"backdrop\",\n      toast: \"toast\",\n      target: \"target\",\n      input: \"input\",\n      width: \"width\",\n      padding: \"padding\",\n      background: \"background\",\n      position: \"position\",\n      grow: \"grow\",\n      customClass: \"customClass\",\n      timer: \"timer\",\n      animation: \"animation\",\n      allowOutsideClick: \"allowOutsideClick\",\n      allowEscapeKey: \"allowEscapeKey\",\n      allowEnterKey: \"allowEnterKey\",\n      showConfirmButton: \"showConfirmButton\",\n      showCancelButton: \"showCancelButton\",\n      confirmButtonText: \"confirmButtonText\",\n      cancelButtonText: \"cancelButtonText\",\n      confirmButtonColor: \"confirmButtonColor\",\n      cancelButtonColor: \"cancelButtonColor\",\n      confirmButtonClass: \"confirmButtonClass\",\n      cancelButtonClass: \"cancelButtonClass\",\n      confirmButtonAriaLabel: \"confirmButtonAriaLabel\",\n      cancelButtonAriaLabel: \"cancelButtonAriaLabel\",\n      buttonsStyling: \"buttonsStyling\",\n      reverseButtons: \"reverseButtons\",\n      focusConfirm: \"focusConfirm\",\n      focusCancel: \"focusCancel\",\n      showCloseButton: \"showCloseButton\",\n      closeButtonAriaLabel: \"closeButtonAriaLabel\",\n      showLoaderOnConfirm: \"showLoaderOnConfirm\",\n      preConfirm: \"preConfirm\",\n      imageUrl: \"imageUrl\",\n      imageWidth: \"imageWidth\",\n      imageHeight: \"imageHeight\",\n      imageAlt: \"imageAlt\",\n      imageClass: \"imageClass\",\n      inputPlaceholder: \"inputPlaceholder\",\n      inputValue: \"inputValue\",\n      inputOptions: \"inputOptions\",\n      inputAutoTrim: \"inputAutoTrim\",\n      inputAttributes: \"inputAttributes\",\n      inputValidator: \"inputValidator\",\n      inputClass: \"inputClass\",\n      progressSteps: \"progressSteps\",\n      currentProgressStep: \"currentProgressStep\",\n      progressStepsDistance: \"progressStepsDistance\"\n    },\n    outputs: {\n      beforeOpen: \"beforeOpen\",\n      open: \"open\",\n      close: \"close\",\n      confirm: \"confirm\",\n      cancel: \"cancel\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function SwalComponent_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return SwalComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * [swal] directive. It takes a value that defines the Sweet Alert and can be of three types:\n *\n * 1) A simple array of two or three strings defining [title, text, type] - the type being optional, ex:\n *\n *    <button [swal]=\"['Title', 'Text']\">Click me</button>\n *\n * 2) A native SweetAlert2 options object, ex:\n *\n *    <button [swal]=\"{ title: 'Title', text: 'Text' }\">Click me</button>\n *\n * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:\n *\n *    <button [swal]=\"mySwal\">Click me</button>\n *    <swal #mySwal title=\"Title\" text=\"Text\"></swal>\n */\n\n\nlet SwalDirective = /*#__PURE__*/(() => {\n  class SwalDirective {\n    /**\n     * @param {?} viewContainerRef\n     * @param {?} resolver\n     */\n    constructor(viewContainerRef, resolver) {\n      this.viewContainerRef = viewContainerRef;\n      this.resolver = resolver;\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n       *\n       * Example:\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n\n      this.confirm = new EventEmitter();\n      /**\n       * Emits when the user clicks \"Cancel\" (or dismisses the modal by any other way).\n       * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the\n       * value of a rejected \"preConfirm\".\n       *\n       * Example:\n       *     public handleCancel(reason: string): void {\n       *         // reason can be 'cancel', 'overlay', 'close', and 'timer'\n       *         // ... do something\n       *     }\n       */\n\n      this.cancel = new EventEmitter();\n    }\n    /**\n     * SweetAlert2 options or a SwalComponent instance.\n     * See the class doc block for more informations.\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    set swal(options) {\n      if (options instanceof SwalComponent) {\n        this.swalInstance = options;\n      } else if (Array.isArray(options)) {\n        this.swalOptions = Swal.argsToParams(options);\n      } else {\n        this.swalOptions = options;\n      }\n    }\n    /**\n     * OnInit lifecycle handler.\n     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and\n     * (cancel) outputs to reemit on the directive.\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (!this.swalInstance) {\n        /** @type {?} */\n        const factory = this.resolver.resolveComponentFactory(SwalComponent);\n        this.swalRef = this.viewContainerRef.createComponent(factory);\n        this.swalInstance = this.swalRef.instance;\n      }\n    }\n    /**\n     * OnDestroy lifecycle handler.\n     * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.swalRef) {\n        this.swalRef.destroy();\n      }\n    }\n    /**\n     * Click handler.\n     * The directive listens for onclick events on its host element.\n     * When this happens, it shows the <swal> attached to this directive.\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onHostClicked(event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n\n      if (this.swalOptions) {\n        this.swalInstance.options = this.swalOptions;\n      }\n      /** @type {?} */\n\n\n      const confirmSub = this.swalInstance.confirm.asObservable().subscribe(v => this.confirm.emit(v));\n      /** @type {?} */\n\n      const cancelSub = this.swalInstance.cancel.asObservable().subscribe(v => this.cancel.emit(v));\n      this.swalInstance.show().then(unsubscribe);\n      /**\n       * @return {?}\n       */\n\n      function unsubscribe() {\n        confirmSub.unsubscribe();\n        cancelSub.unsubscribe();\n      }\n    }\n\n  }\n\n  SwalDirective.ɵfac = function SwalDirective_Factory(t) {\n    return new (t || SwalDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  SwalDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SwalDirective,\n    selectors: [[\"\", \"swal\", \"\"]],\n    hostBindings: function SwalDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function SwalDirective_click_HostBindingHandler($event) {\n          return ctx.onHostClicked($event);\n        });\n      }\n    },\n    inputs: {\n      swal: \"swal\"\n    },\n    outputs: {\n      confirm: \"confirm\",\n      cancel: \"cancel\"\n    }\n  });\n  /** @nocollapse */\n\n  return SwalDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * \\@internal\n * Holds a consumer's Angular template and displays it on a Sweet Alert.\n * See SwalPartialDirective for info about the covered feature.\n */\n\n\nlet SwalPartialComponent = /*#__PURE__*/(() => {\n  class SwalPartialComponent {}\n\n  SwalPartialComponent.ɵfac = function SwalPartialComponent_Factory(t) {\n    return new (t || SwalPartialComponent)();\n  };\n\n  SwalPartialComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: SwalPartialComponent,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      template: \"template\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"]],\n    template: function SwalPartialComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, SwalPartialComponent_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    directives: [ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return SwalPartialComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * A structural directive that lets you use Angular templates inside of Sweet Alerts.\n * There are different targetable zones in a Sweet Alert: title, content, confirmButton, cancelButton, buttonsWrapper.\n * The default target is the content zone.\n *\n * Usage in your component's TypeScript code-behind (if you use another target than \"content\"):\n *\n * \\@Component({ ... })\n *     export class MyComponent {\n *         public constructor(public readonly swalTargets: SwalPartialTargets) {\n *         }\n *     }\n *\n * Usage in the template:\n *\n *     <swal title=\"Fill the form\" (confirm)=\"confirmHandler()\">\n *         <!-- This form will be displayed as the alert main content\n *              Targets the alert's main content zone by default -->\n *         <form *swalPartial [formControl]=\"myForm\">\n *             ...\n *         </form>\n *\n *         <!-- This targets the confirm button's inner content\n *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->\n *         <ng-container *swalPartial=\"swalTargets.confirmButton\">\n *              Send ({{ secondsLeft }} seconds left)\n *         </ng-container>\n *     <swal>\n */\n\n\nlet SwalPartialDirective = /*#__PURE__*/(() => {\n  class SwalPartialDirective {\n    /**\n     * @param {?} resolver\n     * @param {?} injector\n     * @param {?} app\n     * @param {?} templateRef\n     * @param {?} swalTargets\n     * @param {?} swalComponent\n     */\n    constructor(resolver, injector, app, templateRef, swalTargets, swalComponent) {\n      this.resolver = resolver;\n      this.injector = injector;\n      this.app = app;\n      this.templateRef = templateRef;\n      this.swalTargets = swalTargets;\n      this.swalComponent = swalComponent;\n    }\n    /**\n     * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will\n     * receive the consumer's template.\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.beforeOpenSubscription = this.swalComponent.beforeOpen.asObservable().subscribe(() => {\n        //=> Create the SwalPartialComponent on the target DOM node in the Sweet Alert\n\n        /** @type {?} */\n        const targetEl = this.swalPartial ? this.swalPartial() : this.swalTargets.content();\n        /** @type {?} */\n\n        const factory = this.resolver.resolveComponentFactory(SwalPartialComponent);\n        this.partialRef = factory.create(this.injector, [], targetEl); //=> Apply the consumer's template on the component\n\n        this.partialRef.instance.template = this.templateRef; //=> Make the Angular app aware of that detached view so change detection works\n\n        this.app.attachView(this.partialRef.hostView);\n      });\n      this.closeSubscription = this.swalComponent.close.asObservable().subscribe(() => {\n        //=> Detach the partial component from the app and destroy it\n        this.app.detachView(this.partialRef.hostView);\n        this.partialRef.destroy();\n      });\n    }\n    /**\n     * Unsubscribes from the Sweet Alert appearance/disappearance.\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.beforeOpenSubscription.unsubscribe();\n      this.closeSubscription.unsubscribe();\n    }\n\n  }\n\n  SwalPartialDirective.ɵfac = function SwalPartialDirective_Factory(t) {\n    return new (t || SwalPartialDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(SwalPartialTargets), ɵngcc0.ɵɵdirectiveInject(SwalComponent, 1));\n  };\n\n  SwalPartialDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SwalPartialDirective,\n    selectors: [[\"\", \"swalPartial\", \"\"]],\n    inputs: {\n      swalPartial: \"swalPartial\"\n    }\n  });\n  /** @nocollapse */\n\n  return SwalPartialDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n\nlet SweetAlert2Module = /*#__PURE__*/(() => {\n  class SweetAlert2Module {\n    /**\n     * @param {?=} defaultSwalOptions\n     * @return {?}\n     */\n    static forRoot(defaultSwalOptions) {\n      return {\n        ngModule: SweetAlert2Module,\n        providers: [swalDefaultsProvider(defaultSwalOptions)]\n      };\n    }\n\n  }\n\n  SweetAlert2Module.ɵfac = function SweetAlert2Module_Factory(t) {\n    return new (t || SweetAlert2Module)();\n  };\n\n  SweetAlert2Module.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SweetAlert2Module\n  });\n  SweetAlert2Module.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [SwalPartialTargets],\n    imports: [[CommonModule]]\n  });\n  return SweetAlert2Module;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SweetAlert2Module, {\n    declarations: function () {\n      return [SwalComponent, SwalPartialDirective, SwalPartialComponent, SwalDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [SwalComponent, SwalPartialDirective, SwalDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n\nexport { SwalPartialTargets, SwalComponent, SwalDirective, SwalPartialDirective, SweetAlert2Module, SwalDefaults as ɵa, swalDefaultsProvider as ɵb, SwalPartialComponent as ɵc }; //# sourceMappingURL=sweetalert2-ngx-sweetalert2.js.map","map":null,"metadata":{},"sourceType":"module"}